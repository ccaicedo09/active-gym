package com.activegym.activegym.security.auth;

import com.activegym.activegym.repository.Users.UserRepository;
import com.activegym.activegym.security.jwt.JwtService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Service class responsible for handling authentication operations.
 * It manages login requests and retrieves user roles.
 * @since v1.0
 * @author Carlos Esteban Castro Caicedo
 */
@Service
@RequiredArgsConstructor
public class AuthService {

    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final JwtService jwtService;

    /**
     * <p>Authenticates the user based on the provided login request,
     * generates a JWT token, and sets a roles cookie.</p>
     *
     * <p>This authentication is done using the {@code AuthenticationManager}. In case the user is found and the login is successful, a token will be generated by the {@code JwtService} and it will be obtained through the mentioned service for returning it on the response. </p>
     *
     * @param request the login request containing email and password
     * @return a {@link ResponseEntity} containing the JWT token and the username
     *         in the response body, along with a cookie header with user roles
     * @throws BadCredentialsException if the credentials are invalid or user does not exist.
     */
    public ResponseEntity<AuthResponse> login(LoginRequest request) {

        authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword()));

        UserDetails user = userRepository.findByEmail(request.getEmail()).orElseThrow(() -> new BadCredentialsException(""));

        String token = jwtService.getToken(user);

        String userName = jwtService.extractUserName(token);

        String profilePicture = jwtService.getProfilePictureFromToken(token);

        List<String> authorities = user.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .toList();

        ResponseCookie rolesCookie = ResponseCookie.from("user_roles", String.join("|", authorities))
                .httpOnly(true)
                .path("/")
                .maxAge(24 * 60 * 60)
                .sameSite("Strict")
                .build();

        return ResponseEntity.ok()
                .header(HttpHeaders.SET_COOKIE, rolesCookie.toString())
                .body(AuthResponse.builder()
                        .token(token)
                        .userName(userName)
                        .profilePicture(profilePicture)
                        .build());
    }

    /**
     * Gets authenticated user roles using the Spring's Security Context Holder.
     *
     * @return a List of roles as strings {@link String}.
     */
    public List<String> getUserRoles() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .toList();
    }
}
